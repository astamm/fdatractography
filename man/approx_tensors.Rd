% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tensors.R
\name{approx_tensors}
\alias{approx_tensors}
\title{Tensor Interpolation}
\usage{
approx_tensors(x, tensors, xout, method = "linear", n = 50, yleft,
  yright, rule = 1, ties = mean)
}
\arguments{
\item{x}{Numeric vector specifying the locations at which tensors are
defined.}

\item{tensors}{List of \code{\link{tensor}} objects to be interpolated.}

\item{xout}{An optional set of numeric values specifying where interpolation
is to take place.}

\item{method}{Specifies the interpolation method to be used. Choices are
"linear" [default] or "log" for interpolating in the log-Euclidean space.}

\item{n}{If \code{xout} is not specified, interpolation takes place at
\code{n} equally spaced points spanning the interval \code{[min(x),
max(x)]}. Default is \code{n = 50}.}

\item{yleft}{The value to be returned when input \code{x} values are less
than \code{min(x)}. The default is defined by the value of \code{rule}
given below.}

\item{yright}{The value to be returned when input \code{x} values are greater
than \code{max(x)}. The default is defined by the value of \code{rule}
given below.}

\item{rule}{An integer (of length 1 or 2) describing how interpolation is to
take place outside the interval \code{[min(x), max(x)]}. If \code{rule} is
1 then \code{NA}s are returned for such points and if it is 2, the value at
the closest data extreme is used. Use, e.g., \code{rule = 2:1}, if the left
and right side extrapolation should differ.}

\item{ties}{Handling of tied \code{x} values. Either a function with a single
vector argument returning a single number result or the string
\code{"ordered"}.}
}
\value{
A \code{list} with components \code{x} and \code{y}, containing
  \code{n} coordinates which interpolate the given data points according to
  the \code{method} (and \code{rule}) desired.
}
\description{
The function \code{approx_tensors} is the analog to the
\code{\link[stats]{approx}} function for interpolating
\code{\link{tensor}}-valued data.
}
\details{
If \code{method == "linear"}, it performs linear tensor interpolation
according to the paper by Gahm, J. K., Wisniewski, N., Kindlmann, G., Kung,
G. L., Klug, W. S., Garfinkel, A., & Ennis, D. B. (2012, October). Linear
invariant tensor interpolation applied to cardiac diffusion tensor MRI. In
International Conference on Medical Image Computing and Computer-Assisted
Intervention (pp. 494-501). Springer, Berlin, Heidelberg. If \code{method ==
"log"}, it performs log-Euclidean tensor interpolation according to the paper
by Arsigny, V., Fillard, P., Pennec, X. and Ayache, N. (2006) ‘Log-Euclidean
metrics for fast and simple calculus on diffusion tensors.’, Magnetic
resonance in medicine : official journal of the Society of Magnetic Resonance
in Medicine / Society of Magnetic Resonance in Medicine, 56(2), pp. 411–21.
doi: 10.1002/mrm.20965.
}
\examples{
theta <- c(0, pi/6, pi/4, pi/3, pi/2)
R <- NULL
for (i in seq_along(theta)) {
  th <- theta[i]
  R[[i]] <- cbind(
    c(cos(th), sin(th), 0),
    c(-sin(th), cos(th), 0),
    c(0, 0, 1)
  )
}
L <- diag(c(1.7, 0.3, 0.1))
D <- purrr::map(R, ~ . \%*\% L \%*\% t(.))
s <- seq(0, 1, length.out = length(theta))
approx_tensors(s, D)
approx_tensors(s, D, method = "log")
}
